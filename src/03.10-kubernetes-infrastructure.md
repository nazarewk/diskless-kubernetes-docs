
## Infrastruktura _Kubernetesa_

Infrastrukturę definiuję jako część odpowiadającą za funkcjonowanie klastra,
a nie za aplikacje na nim działające.
Z infrastrukturą wiążę pojęcie administracji klastrem.

Zdecydowałem się przybliżyć temat na podstawie
[jednego diagramu znalezionego na wikimedia.org](https://commons.wikimedia.org/wiki/File:Kubernetes.png):

![Architektura Kubernetes](assets/kubernetes-architecture.png){width=500 height=354}\

Na ilustracji możemy wyróżnić 5 grup funkcjonalnych:

1. _Developer/Operator_, czyli administrator lub programista korzystający z klastra,
2. _Users_, czyli użytkowników aplikacji działających w klastrze,
3. _Kubernetes Master_, czyli węzeł zarządzający (zwykle więcej niż jeden),
4. _Kubernetes Node_, czyli jeden z wielu węzłów roboczych, na których działają
  aplikacje,
5. _Plugin Network_, czyli wtyczka sieciowa realizująca lub konfigurująca
  połączenia pomiędzy kontenerami działającymi w ramach klastra,


#### Węzeł zarządzający

Stan _Kubernetes_ jest przechowywany w [_etcd_](https://coreos.com/etcd/). 
Nazwa wzięła się od Unixowego folderu _/etc_ przechowującego konfigurację 
systemu operacyjnego i litery _d_ oznaczającej system rozproszony (ang. 
distributed system).
Jest to baza danych przechowująca jedynie klucze i wartości
(ang. key-value store). Koncepcyjnie jest prosta, żeby umożliwić skupienie się
na jej wydajności, stabilności i skalowaniu.

Jedynym sposobem zmiany stanu _etcd_ (zakładając, że nie jest wykorzystywane
do innych celów) jest komunikacja z [_kube-apiserver_](https://kubernetes.io/docs/reference/generated/kube-apiserver/). 
Zarówno zewnętrzni  użytkownicy jak i wewnętrzne procesy klastra korzystają z
interfejsu aplikacyjnego REST (ang. REST API) klastra w celu uzyskania
informacji i zmiany jego stanu.

Głównym modułem zarządzającym, który dba o doprowadzenia klastra do oczekiwanego 
stanu jest [_kube-controller-manager_](https://kubernetes.io/docs/reference/generated/kube-controller-manager/).
Uruchamia on pętle kontrolujące klaster, na której bazuje wiele procesów
kontrolnych jak na przykład kontroler replikacji i kontroler kont serwisowych.

Modułem zarządzającym zasobami klastra jest [_kube-scheduler_](https://kubernetes.io/docs/reference/generated/kube-scheduler/).
Decyduje on na których węzłach uruchamiać aplikacje, żeby zaspokoić popyt na 
zasoby jednocześnie nie przeciążając pojedynczych węzłów klastra.

#### Węzeł roboczy

Podstawowym procesem działającym na węzłach roboczych jest [_kubelet_](https://kubernetes.io/docs/reference/generated/kubelet/).
Monitoruje i kontroluje kontenery działające w ramach jednego węzła.
Na przykład wiedząc, że na węźle mają działać 2 instancje aplikacji
dba o to, żeby restartować instancje działające nieprawidłowo i/lub dodawać nowe.

Drugim najważniejszym procesem węzła roboczego jest _kube-proxy_ odpowiadające
za przekierowywanie ruchu sieciowego do odpowiednich kontenerów w ramach 
klastra.

Ostatnim opcjonalnym elementem węzła roboczego jest [_cAdvisor_](https://github.com/google/cadvisor)
(Container Advisor), który monitoruje zużycie zasobów i wydajność kontenerów
w ramach jednego klastra.

#### Wtyczka sieciowa

Podstawowym założeniem _Kubernetesa_ jest posiadanie własnego adresu IP przez każdą
aplikację działającą w klastrze, ale nie narzuca żadnego rozwiązania je
realizującego.

Administrator (lub skrypt konfigurujący) klastra musi zadbać o to, żeby
skonfigurować wtyczkę sieciową realizującą to założenie.

Najprostszym koncepcyjnie rozwiązaniem jest stworzenie na każdym węźle wpisów
_iptables_ przekierowujących adresy IP na wszystkie inne węzły.

Jednymi z najpopularniejszymi rozwiązaniami są:
[Flannel](https://github.com/coreos/flannel#flannel) i 
[Project Calico](https://www.projectcalico.org/).

#### Komunikacja sieciowa

Materiały źródłowe:

- https://www.slideshare.net/weaveworks/kubernetes-networking-78049891
- https://jvns.ca/blog/2016/12/22/container-networking/
- https://medium.com/\@anne_e_currie/kubernetes-aws-networking-for-dummies-like-me-b6dedeeb95f3

4 rodzaje komunikacji sieciowej:

1. wewnątrz Podów (localhost)
2. między Podami (trasowanie lub nakładka sieciowa - overlay network)
3. między Podami i Serwisami (kube-proxy)
4. świata z Serwisami

W skrócie:

- _Kubernetes_ uruchamia _Pody_, które implementują Serwisy,
- _Pody_ potrzebują _Sieci Podów_ - trasowanych lub nakładkę sieciową,
- _Sieć Podów_ jest sterowana przez _CNI_ (Container Network Interface),
- Klient łączy się do Serwisów przez wirtualne IP Klastra,
- _Kubernetes_ ma wiele sposobów na wystawienie Serwisów poza klaster,

#### Zarządzanie dostępami

Podstawowymi pojęciami związanymi z zarządzaniem dostępami w _Kubernetesie_ są
uwierzytelnianie, autoryzacja i _Namespace_.

##### Uwierzytelnianie

Pierwszym krokiem w każdym zapytaniu do API jest uwierzytelnienie,
czyli weryfikacja, że użytkownik (czy to aplikacja) jest tym za kogo się podaje.
Podstawowymi sposobami uwierzytelniania są:

- certyfikaty klienckie X509,
- statyczne przepustki (ang. _token_),
- przepustki rozruchowe (ang. _bootstrap tokens_),
- statyczny plik z hasłami,
- przepustki kont serwisowych (ang. _ServiceAccount_ tokens),
- przepustki OpenID Connect,
- Webhook (zapytanie uwierzytelniające do zewnętrznego serwisu),
- proxy uwierzytelniające,

Ze względu na prostotę i uniwersalność rozwiązania w tej pracy będę korzystał
z _ServiceAccount_.

##### Autoryzacja

Drugim krokiem jest autoryzacja, czyli weryfikacja, że użytkownik jest
uprawniony do korzystania z danego zasobu.

Najpopularniejszym sposobem autoryzacji jest [RBAC (Role Based Access Control)](https://kubernetes.io/docs/admin/authorization/rbac/).
Odbywa się ona na podstawie ról (_Role_ i _ClusterRole_), które nadają
uprawnienia i są przypisywane konkretnym użytkownikom lub kontom przez
_RoleBinding_ i _ClusterRoleBinding_.

_Namespace_ (przestrzeń nazw) jest logicznie odseparowaną częścią klastra _Kubernetes_.
Pozwala na współdzielenie jednego klastra przez wielu niezaufanych użytkowników.
Standardowym zastosowaniem jest wydzielanie środowisk produkcyjnych, QA i
deweloperskich.

Jak nazwa wskazuje role z dopiskiem _Cluster_ mogą dać dostęp do wszystkich
przestrzeni nazw jednocześnie oraz zasobów takowych nie posiadających.
Przykładem zasobu nie posiadającego swojej przestrzeni nazw jest węzeł (_Node_)
lub zakończenie API _/healthz_.

Role bez dopisku _Cluster_ operują w ramach jednej przestrzeni nazw.
