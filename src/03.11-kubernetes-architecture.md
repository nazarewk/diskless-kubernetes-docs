## Architektura

Architekturę klastra definiuję jako część aplikacyjną, czyli wszystkie
funkcjonalności dostępne po przeprowadzeniu prawidłowej konfiguracji klastra i
oddaniu węzłów do użytku.
Z architekturą wiążę pojęcia korzystania z klastra, stanu i obiektów `k8s`.

#### Obiekty Kubernetes API

[`Obiekty Kubernetesa`](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/)
są trwale przechowywane w `etcd` i definiują, jak wcześniej wyjaśniłem, 
pożądany stan klastra.
Szczegółowy opis konwencji API obiektów możemy znaleźć w [odnośniku](https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md). 

Jako użytkownicy klastra operujemy na ich reprezentacji w formacie YAML, a
rzadziej JSON, na przykład:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod 
  namespace: my-namespace
  uid: 343fc305-c854-44d0-9085-baed8965e0a9
  labels:
    resources: high
  annotations:
    app-type: qwe
spec:
  containers:
  - image: ubuntu:trusty
    command: ["echo"]
    args: ["Hello World"]
  ...
status:
  podIP: 127.12.13.14
  ...
```

W każdym obiekcie możemy wyróżnić trzy obowiązkowe i dwa opcjonalne pola:

- `apiVersion`: obowiązkowa wersja API `k8s`,
- `kind`: obowiązkowy typ obiektu zdefiniowanego w specyfikacji `apiVersion`,
- `metadata`
  - `namespace`: opcjonalna (domyślna `default`) przestrzeń nazw do której należy
    obiekt,
  - `name`: obowiązkowa i unikalna w ramach przestrzeni nazw nazwa obiektu,
  - `uid`: unikalny identyfikator obiektu tylko do odczytu,
  - `labels`: opcjonalny zbiór kluczy i wartości ułatwiających identyfikację i
    grupowanie obiektów,
  - `annotations`: opcjonalny zbiór kluczy i wartości wykorzystywanych przez
    zewnętrzne lub własne narzędzia,  
- `spec`: z definicji opcjonalna, ale zwykle wymagana specyfikacja obiektu 
  wpływająca na jego funkcjonowanie,
- `status`: opcjonalny aktualny stan obiektu tylko do odczytu,

#### Podstawowe rodzaje obiektów aplikacyjnych

Ważną kwestią jest rozróżnienie obiektów imperatywnych i deklaratywnych. 
Obiekty imperatywne reprezentują wykonanie akcji, a deklaratywne określają stan
w jakim klaster powinien się znaleźć.

##### Pod`

[`Pod`](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)
jest najmniejszą jednostką aplikacyjną w `k8s`. Reprezentuje
nierozłącznie powiązaną (np. współdzielonymi zasobami) grupę jednego lub więcej
kontenerów.

`Pod` w odróżnieniu od innych obiektów reprezentuje aktualnie działającą
aplikację. Są bezustannie uruchamiane i wyłączane przez kontrolery. Trwałość
danych można uzyskać jedynie przydzielając im zasoby dyskowe.

`Pody` nie powinny być zarządzane bezpośrednio, jedynie przez kontrolery.
Najczęściej konfigurowane są przez `PodTemplateSpec`, czyli szablony
ich specyfikacji.

Kontenery wewnątrz `Poda` współdzielą adres IP i mogą komunikować się przez
`localhost` i standardowe metody komunikacji międzyprocesowej.

Dodatkowo kontenery wewnątrz `Pod`ów obsługują 2 rodzaje [próbników](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes):
`livenessProbe` i `readinessProbe`.
Pierwszy określa, czy kontener działa, jeżeli nie to powinien być zrestartowany.
Drugi określa czy kontener jest gotowy do obsługi zapytań, kontener jest
wyrejestrowywany z `Service` na czas nieprzechodzenia `readinessProbe`.

##### ReplicaSet`

[`ReplicaSet`](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)
jest następcą `ReplicaControllera`, czyli imperatywnym kontrolerem dbającym o
działanie określonej liczby `Pod`ów w klastrze.

Jest to bardzo prosty kontroler i nie powinien być używany bezpośrednio.

##### Deployment`

[`Deployment`](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
pozwala na deklaratywne aktualizacje `Pod`ów i `ReplicaSet`ów.
Korzystanie z ww. bezpośrednio nie jest zalecane.

Zmiany `Deployment`ów wprowadzane są przez tak zwane `rollouty`. Każdy
ma swój status i może zostać wstrzymany lub przerwany. `Rollouty` mogą zostać
aktywowane automatycznie przez zmianę specyfikacji `Pod`a przez `.spec.template`.

Rewizje `Deployment`u są zmieniane tylko w momencie `rollout`u. Operacja
operacja skalowania nie uruchamia `rollout`u, a więc nie zmienia rewizji.

Podstawowe przypadki użycia `Deployment` to:

- uruchamianie `ReplicaSet`ów w tle przez `.spec.replicas`,
- deklarowanie nowego stanu `Pod`ów zmieniając `.spec.template`,
- cofanie zmian do poprzednich rewizji `Deployment`u (poprzednie wersje `Pod`ów)
  komendą `kubectl rollout undo`,
- skalowanie `Deployment`u w celu obsługi większego obciążenia przykładową 
  komendą
  `kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80`,
- wstrzymywanie `Deployment` w celu wprowadzenia poprawek komendą
  `kubectl rollout pause deployment/nginx-deployment`,
- czyszczenie historii `ReplicaSet`ów przez ograniczanie liczby wpisów w
  `.spec.revisionHistoryLimit`,

Przykładowy `Deployment` tworzący 3 repliki serwera `nginx`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

Pole `.spec.selector` definiuje w jaki sposób `Deployment` ma znaleźć `Pod`y,
którymi ma zarządzać. Selektor powinien zgadzać się ze zdefiniowanym szablonem.

##### StatefulSet

[`StatefulSet`](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)
jest kontrolerem podobnym do `Deployment`u, ale umożliwiającym zachowanie stanu
`Pod`ów.

W przeciwieństwie do `Deployment` `StatefulSet` nadaje każdemu uruchomionemu
`Pod`owi stały unikalny identyfikator, który zostają zachowane mimo restartów
i przenoszenia `Pod`ów. Identyfikatory można zastosować między innymi do:

- trwałych i unikalnych identyfikatorów wewnątrz sieci,
- trwałych zasobów dyskowych,
- sekwencyjne uruchamianie i skalowanie aplikacji,
- sekwencyjne zakańczanie i usuwanie aplikacji,
- sekwencyjne, zautomatyzowane aktualizacje aplikacji, 


##### DaemonSet

[`DaemonSet`](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)
jest kontrolerem upewniającym się, że przynajmniej jeden `Pod` działa na każdym
lub wybranych węzłach klastra.

Do jego typowych zastosowań należy implementacja narzędzi wymagających agenta
na każdym z węzłów:

- rozproszone systemy dyskowe, np. `glusterd`, `ceph`,
- zbieracze logów, np. `fluentd`, `logstash`,
- monitorowanie węzłów, np. `Prometheus Node Exporter`, `collectd`,

##### Job i CronJob

[`Job`](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)
pozwala na jednorazowe uruchomienie `Pod`ów, które wykonują akcję i się kończą.
Istnieją 3 tryby wykonania: niezrównoleglony, równoległy i równoległy z
zewnętrzną kolejką zadań.

Domyślnie przy niepowodzeniu uruchamiane są kolejne `Pody` aż zostanie uzyskana
odpowiednia liczba sukcesów.

[`CronJob`](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)
pozwala na tworzenie `Job`ów jednorazowo o określonym czasie lub je powtarzać
zgodnie ze specyfikacją [`cron`](https://en.wikipedia.org/wiki/Cron).
