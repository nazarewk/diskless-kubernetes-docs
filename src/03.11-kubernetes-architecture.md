## Architektura

Architekturę klastra definiuję jako część aplikacyjną, czyli wszystkie
funkcjonalności dostępne po przeprowadzeniu prawidłowej konfiguracji klastra i
oddaniu węzłów do użytku.
Z architekturą wiążę pojęcia korzystania z klastra, stanu i obiektów _Kubernetesa_.

#### Obiekty Kubernetes API

[_Obiekty Kubernetesa_](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/)
są trwale przechowywane w _etcd_ i definiują, jak wcześniej wyjaśniłem, 
pożądany stan klastra.
Szczegółowy opis konwencji API obiektów możemy znaleźć w [odnośniku](https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md). 

Jako użytkownicy klastra operujemy na ich reprezentacji w formacie YAML, a
rzadziej JSON, na przykład:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod 
  namespace: my-namespace
  uid: 343fc305-c854-44d0-9085-baed8965e0a9
  labels:
    resources: high
  annotations:
    app-type: qwe
spec:
  containers:
  - image: ubuntu:trusty
    command: ["echo"]
    args: ["Hello World"]
  ...
status:
  podIP: 127.12.13.14
  ...
```

W każdym obiekcie możemy wyróżnić trzy obowiązkowe i dwa opcjonalne pola:

- _apiVersion_: obowiązkowa wersja API _Kubernetes_,
- _kind_: obowiązkowy typ obiektu zdefiniowanego w specyfikacji _apiVersion_,
- _metadata_
  - _namespace_: opcjonalna (domyślna _default_) przestrzeń nazw do której należy
    obiekt,
  - _name_: obowiązkowa i unikalna w ramach przestrzeni nazw nazwa obiektu,
  - _uid_: unikalny identyfikator obiektu tylko do odczytu,
  - _labels_: opcjonalny zbiór kluczy i wartości ułatwiających identyfikację i
    grupowanie obiektów,
  - _annotations_: opcjonalny zbiór kluczy i wartości wykorzystywanych przez
    zewnętrzne lub własne narzędzia,  
- _spec_: z definicji opcjonalna, ale zwykle wymagana specyfikacja obiektu 
  wpływająca na jego funkcjonowanie,
- _status_: opcjonalny aktualny stan obiektu tylko do odczytu,

#### Podstawowe rodzaje obiektów aplikacyjnych

Ważną kwestią jest rozróżnienie obiektów imperatywnych i deklaratywnych. 
Obiekty imperatywne reprezentują wykonanie akcji, a deklaratywne określają stan
w jakim klaster powinien się znaleźć.

##### _Pod_

[_Pod_](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)
jest najmniejszą jednostką aplikacyjną w _Kubernetesie_. Reprezentuje
nierozłącznie powiązaną (np. współdzielonymi zasobami) grupę jednego lub więcej
kontenerów.

_Pod_ w odróżnieniu od innych obiektów reprezentuje aktualnie działającą
aplikację. Są bezustannie uruchamiane i wyłączane przez kontrolery. Trwałość
danych można uzyskać jedynie przydzielając im zasoby dyskowe.

_Pody_ nie powinny być zarządzane bezpośrednio, jedynie przez kontrolery.
Najczęściej konfigurowane są przez _PodTemplateSpec_, czyli szablony
ich specyfikacji.

Kontenery wewnątrz _Poda_ współdzielą adres IP i mogą komunikować się przez
_localhost_ i standardowe metody komunikacji międzyprocesowej.

Dodatkowo kontenery wewnątrz _Podów_ obsługują 2 rodzaje [próbników](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes):
_livenessProbe_ i _readinessProbe_.
Pierwszy określa, czy kontener działa, jeżeli nie to powinien być zrestartowany.
Drugi określa czy kontener jest gotowy do obsługi zapytań, kontener jest
wyrejestrowywany z _Service_ na czas nieprzechodzenia _readinessProbe_.

##### _ReplicaSet_

[_ReplicaSet_](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)
jest następcą _ReplicaControllera_, czyli imperatywnym kontrolerem dbającym o
działanie określonej liczby _Podów_ w klastrze.

Jest to bardzo prosty kontroler i nie powinien być używany bezpośrednio.

##### _Deployment_

[_Deployment_](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
pozwala na deklaratywne aktualizacje _Podów_ i _ReplicaSetów_.
Korzystanie z ww. bezpośrednio nie jest zalecane.

Zmiany _Deploymentów_ wprowadzane są przez tak zwane _rollouty_. Każdy
ma swój status i może zostać wstrzymany lub przerwany. _Rollouty_ mogą zostać
aktywowane automatycznie przez zmianę specyfikacji _Pod_a przez _.spec.template_.

Rewizje _Deployment_u są zmieniane tylko w momencie _rollout_u. Operacja
operacja skalowania nie uruchamia _rollout_u, a więc nie zmienia rewizji.

Podstawowe przypadki użycia _Deployment_ to:

- uruchamianie _ReplicaSetów_ w tle przez _.spec.replicas_,
- deklarowanie nowego stanu _Podów_ zmieniając _.spec.template_,
- cofanie zmian do poprzednich rewizji _Deployment_u (poprzednie wersje _Podów_)
  komendą _kubectl rollout undo_,
- skalowanie _Deployment_u w celu obsługi większego obciążenia przykładową 
  komendą
  _kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80_,
- wstrzymywanie _Deployment_ w celu wprowadzenia poprawek komendą
  _kubectl rollout pause deployment/nginx-deployment_,
- czyszczenie historii _ReplicaSetów_ przez ograniczanie liczby wpisów w
  _.spec.revisionHistoryLimit_,

Przykładowy _Deployment_ tworzący 3 repliki serwera _nginx_:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

Pole _.spec.selector_ definiuje w jaki sposób _Deployment_ ma znaleźć _Pody_,
którymi ma zarządzać. Selektor powinien zgadzać się ze zdefiniowanym szablonem.

##### StatefulSet

[_StatefulSet_](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)
jest kontrolerem podobnym do _Deployment_u, ale umożliwiającym zachowanie stanu
_Podów_.

W przeciwieństwie do _Deployment_u _StatefulSet_ nadaje każdemu uruchomionemu
_Pod_owi stały unikalny identyfikator, który zostają zachowane mimo restartów
i przenoszenia _Podów_. Identyfikatory można zastosować między innymi do:

- trwałych i unikalnych identyfikatorów wewnątrz sieci,
- trwałych zasobów dyskowych,
- sekwencyjne uruchamianie i skalowanie aplikacji,
- sekwencyjne zakańczanie i usuwanie aplikacji,
- sekwencyjne, zautomatyzowane aktualizacje aplikacji, 


##### DaemonSet

[_DaemonSet_](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)
jest kontrolerem upewniającym się, że przynajmniej jeden _Pod_ działa na każdym
lub wybranych węzłach klastra.

Do jego typowych zastosowań należy implementacja narzędzi wymagających agenta
na każdym z węzłów:

- rozproszone systemy dyskowe, np. _glusterd_, _ceph_,
- zbieracze logów, np. _fluentd_, _logstash_,
- monitorowanie węzłów, np. _Prometheus Node Exporter_, _collectd_,

##### Job i CronJob

[_Job_](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)
pozwala na jednorazowe uruchomienie _Podów_, które wykonują akcję i się kończą.
Istnieją 3 tryby wykonania: niezrównoleglony, równoległy i równoległy z
zewnętrzną kolejką zadań.

Domyślnie przy niepowodzeniu uruchamiane są kolejne _Pody_ aż zostanie uzyskana
odpowiednia liczba sukcesów.

[_CronJob_](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)
pozwala na tworzenie _Jobów_ jednorazowo o określonym czasie lub je powtarzać
zgodnie ze specyfikacją [_cron_](https://en.wikipedia.org/wiki/Cron).
